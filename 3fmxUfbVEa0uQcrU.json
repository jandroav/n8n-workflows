{
  "nodes": [
    {
      "parameters": {
        "content": "## Daily Evening TriggerÂ  \nSchedules and initiates the EOD workflow each workday evening automatically."
      },
      "id": "51cdf75c-f344-47bc-8813-720dfd63dfa6",
      "name": "Sticky Note",
      "type": "n8n-nodes-base.stickyNote",
      "position": [-784, 80],
      "typeVersion": 1
    },
    {
      "parameters": {
        "content": "## Get ALL issues (Jira)Â  \nRetrieves all Jira issues for the day, including statuses, priorities, assignees, and comment to power the Daily standup summary.",
        "height": 176
      },
      "id": "5dd810b0-4951-4e84-99dc-68eaf1263bb9",
      "name": "Sticky Note1",
      "type": "n8n-nodes-base.stickyNote",
      "position": [-240, -96],
      "typeVersion": 1
    },
    {
      "parameters": {
        "operation": "getAll",
        "returnAll": true,
        "options": {
          "jql": "updated >= -5d AND \"developer[user picker (single user)]\" = \"avazquez@liquibase.com\" ORDER BY created DESC"
        }
      },
      "id": "ba6523be-99fa-4dbc-8f45-d010a7a26e2a",
      "name": "Get ALL issues",
      "type": "n8n-nodes-base.jira",
      "position": [-272, 112],
      "typeVersion": 1,
      "credentials": {
        "jiraSoftwareCloudApi": {
          "id": "cHlXrG05mBLoocuF",
          "name": "Jira SW Cloud account"
        }
      }
    },
    {
      "parameters": {
        "resource": "issueComment",
        "operation": "getAll",
        "issueKey": "={{ $json.key }}",
        "returnAll": true,
        "options": {}
      },
      "id": "9ac6ce53-e12e-47b4-acc0-69e83bd23dc3",
      "name": "Get Comments for Each Issue",
      "type": "n8n-nodes-base.jira",
      "position": [-80, 112],
      "typeVersion": 1,
      "credentials": {
        "jiraSoftwareCloudApi": {
          "id": "cHlXrG05mBLoocuF",
          "name": "Jira SW Cloud account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Merge Jira issues with their comments\n// Input: Items from \"Get Comments for Each Issue\" node (one item per comment)\n// Output: Array of issues with comments embedded\n\nconst commentItems = $input.all();\nconst allIssues = $('Get ALL issues').all();\n\n// Group comments by issue key\n// Comments come from pairedItem which links back to the original issue\nconst commentsByIssue = {};\n\nfor (const commentItem of commentItems) {\n  // Get the issue key from the pairedItem (the original issue that triggered this comment fetch)\n  const pairedItem = commentItem.pairedItem;\n  if (!pairedItem || pairedItem.item === undefined) continue;\n  \n  // Access the original issue data by index\n  const sourceIssue = allIssues[pairedItem.item];\n  if (!sourceIssue || !sourceIssue.json || !sourceIssue.json.key) continue;\n  \n  const issueKey = sourceIssue.json.key;\n  \n  // Initialize array for this issue if needed\n  if (!commentsByIssue[issueKey]) {\n    commentsByIssue[issueKey] = [];\n  }\n  \n  // Add the comment data\n  const comment = commentItem.json;\n  if (comment && (comment.body || comment.author)) {\n    commentsByIssue[issueKey].push({\n      author: comment.author?.displayName || comment.author?.name || 'Unknown',\n      body: comment.body,\n      created: comment.created,\n      updated: comment.updated,\n      id: comment.id\n    });\n  }\n}\n\n// Create result with issues enriched with comments\nconst result = [];\n\nfor (const issueItem of allIssues) {\n  const issueKey = issueItem.json.key;\n  const issue = { ...issueItem.json };\n  \n  // Add comments to the issue\n  const comments = commentsByIssue[issueKey] || [];\n  issue.comments = comments;\n  issue.commentCount = comments.length;\n  \n  result.push({ json: issue });\n}\n\nreturn result;"
      },
      "id": "db70eb05-368d-479b-86a0-e4fcef47286c",
      "name": "Merge Issues with Comments",
      "type": "n8n-nodes-base.code",
      "position": [96, 112],
      "typeVersion": 2
    },
    {
      "parameters": {
        "jsCode": "// n8n Code node: merge all incoming items into a single output array in one item\n\nconst inputItems = $input.all();\nconst combined = [];\n\n// Normalize any value to an array of plain objects\nfunction normalizeToArray(val) {\n  if (typeof val === 'string') {\n    const trimmed = val.trim();\n    try {\n      const parsed = JSON.parse(trimmed);\n      return Array.isArray(parsed) ? parsed : [parsed];\n    } catch {\n      return [{ raw: trimmed }];\n    }\n  }\n  if (Array.isArray(val)) return val;\n  if (val && typeof val === 'object') return [val];\n  return [{ value: val }];\n}\n\n// Merge all items' json into one array\nfor (const item of inputItems) {\n  const source = item.json !== undefined ? item.json : item;\n  const arr = normalizeToArray(source);\n  for (const el of arr) {\n    const obj = el && typeof el === 'object' ? el : { value: el };\n    combined.push(obj);\n  }\n}\n\n// Return a single n8n item containing the whole array\nreturn [\n  {\n    json: {\n      combined,            // All input collapsed into one array\n      count: combined.length\n    }\n  }\n];\n"
      },
      "id": "1a24e9c1-02c4-4348-b24c-b2522b34caea",
      "name": "Flatten Input",
      "type": "n8n-nodes-base.code",
      "position": [272, 112],
      "typeVersion": 2
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.combined }}",
        "options": {
          "systemMessage": "You are an Endâ€‘ofâ€‘Day (EOD) Report generator for engineering teams. Your job is to read Jira issue data with comments and produce a FIRST-PERSON daily standup report that the developer can read aloud during standup meetings. Write as if YOU are the developer reporting on YOUR work. Do not ask questions. Infer context only from the input.\n\nIMPORTANT: Write the entire report in FIRST PERSON (\"I completed...\", \"I'm working on...\", \"I need to...\") as if you are the developer giving a standup update.\n\nINPUT FORMAT\n- The input may be a single object containing { combined: [...], count: N } or a raw array of issue/work items.\n- Each issue includes: key, summary, status, fields, and a comments array.\n- Comments contain: author.displayName, body, created, updated.\n- Extract insights from comment bodies about progress, blockers, decisions, questions, and collaboration.\n- Today's local time context: Asia/Kolkata (IST), unless clearly indicated otherwise.\n\nOUTPUT TEMPLATE\n1) Daily Standup Update\n- Write 2-3 paragraphs in FIRST PERSON describing:\n  - What I accomplished today (completed tickets with context)\n  - What I'm currently working on (in-progress items)\n  - Any blockers or help I need\n- Mine comment threads to provide rich context about WHY things were done, WHAT decisions were made, and WHO I collaborated with.\n- Mention key collaborators by name when comments show teamwork.\n- Be conversational and natural, as if speaking in a standup.\n\n2) Key Metrics\n- Total items I touched today:\n- Items I completed:\n- Items I'm actively working on:\n- Items in my backlog:\n- Comments/discussions I participated in:\n\n3) What I Did Today\n- 3â€“6 bullets in FIRST PERSON (e.g., \"I completed DAT-21057: Fixed the GitHub Actions deployment conflict. After discussing with @TeamMember in comments, I decided to use approach X because...\").\n- For EACH item, deeply analyze ALL comments to extract:\n  - Technical decisions made and rationale\n  - Problems encountered and solutions found\n  - Collaboration and discussions with team members\n  - Questions asked and answers received\n  - Approvals or feedback received\n- Synthesize comment discussions into narrative insights, not just \"had 3 comments\"\n- Quote specific technical details from comments when relevant\n\n4) Blockers & Help Needed\n- Bullets in FIRST PERSON (e.g., \"I'm blocked on DAT-12345 because...\", \"I need help from @Person to...\").\n- Scan ALL comment threads for:\n  - Explicit blocker statements (\"blocked by\", \"waiting on\", \"can't proceed\")\n  - Unanswered questions that need team input\n  - Dependencies on other team members or systems\n  - Review requests or approval needs\n  - Technical challenges where I'm stuck\n- If no blockers found, write \"No blockers - making good progress!\"\n\n5) Tomorrow's Plan\n- 4â€“7 bullets in FIRST PERSON (e.g., \"I'll continue working on...\", \"I plan to start...\", \"I need to follow up on...\").\n- Base this on:\n  - In-progress items that need completion\n  - Action items mentioned in comments\n  - Logical next steps from completed work\n  - Blockers that need resolution\n\n6) Technical Details (Appendix)\n- Brief data for 3â€“5 key tickets: ticket key, summary, status, comment highlights.\n- For tickets with rich comment discussions (commentCount > 2), include:\n  - A 1-2 sentence synthesis of the comment thread\n  - Key technical decisions or insights from comments\n  - Example: \"DAT-12345 (5 comments): Discussion with @Alice about using Redis vs Memcached; decided on Redis for persistence requirements\"\n\nCOMMENT DEEP ANALYSIS RULES (CRITICAL)\n- Read EVERY comment body carefully - this is where the real work insights are\n- For each issue, create a narrative from comments showing:\n  - The problem-solving journey (initial approach â†’ challenges â†’ solution)\n  - Technical discussions and decisions\n  - Collaboration patterns (who helped, who reviewed, who approved)\n  - Open questions or ongoing discussions\n- Look for these patterns in comment bodies:\n  - \"I think we should...\" â†’ decisions made\n  - \"The issue is...\" â†’ problems identified\n  - \"After testing...\" â†’ progress updates\n  - \"We need to...\" â†’ action items\n  - \"Blocked by...\" / \"Waiting for...\" â†’ blockers\n  - \"@mention\" â†’ collaboration\n  - Questions (?) â†’ things needing resolution\n- Ignore comments that are just noise: \"+1\", \"LGTM\", \"thanks\", \"approved\" (unless approval is contextually important)\n- Prioritize comments from today (check created field)\n- Transform comment insights into first-person narrative\n\nVOICE & TONE\n- Sound natural and conversational, like a real standup\n- Be specific with ticket numbers and context\n- Show your thought process and decision-making\n- Acknowledge collaboration (\"I worked with @Person...\")\n- Be honest about challenges and blockers\n- Use technical terms appropriately\n\nCLASSIFICATION RULES\n- Completed = statusCategory.key: done OR resolution present\n- In Progress = status.name: In Progress OR statusCategory.key: indeterminate\n- Backlog/To Do = status.name: Backlog/To Do OR statusCategory.key: new\n- Bugs vs Tasks from issuetype.name\n\nFORMATTING RULES\n- Write in first person throughout (I, my, me)\n- Be concise but informative\n- Use bullet points for lists\n- Bold 2-4 critical items (ticket numbers, blocker keywords)\n- Keep section headings as specified\n- If a section has no content, write a natural first-person statement (e.g., \"Nothing completed today, but made progress on several items\")\n\nERROR HANDLING\n- If input is incomplete: \"My data looks incomplete today, but here's what I can report...\"\n\nCONSISTENCY CHECK\n- All six sections present\n- Entirely first-person narrative\n- Comments deeply analyzed and synthesized into insights\n- Ticket references accurate"
        }
      },
      "id": "b1f5ee16-4937-4abb-a529-174939359f2f",
      "name": "Create Summary",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "position": [464, 112],
      "typeVersion": 2.2
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "triggerAtHour": 15,
              "triggerAtMinute": 15
            }
          ]
        }
      },
      "id": "37e04c23-b836-4c71-a611-b7783b3685c4",
      "name": "Daily Evening Trigger",
      "type": "n8n-nodes-base.scheduleTrigger",
      "position": [-464, 112],
      "typeVersion": 1.2
    },
    {
      "parameters": {
        "content": "## Flatten InputÂ  \nNormalizes and flattens the Jira JSON into a lighter structure so downstream nodes can parse consistently.",
        "height": 176
      },
      "id": "0a7d38de-e796-4b60-b9ec-f128d5691b42",
      "name": "Sticky Note2",
      "type": "n8n-nodes-base.stickyNote",
      "position": [176, 288],
      "typeVersion": 1
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "claude-3-5-haiku-20241022",
          "mode": "list",
          "cachedResultName": "Claude Haiku 3.5"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.3,
      "position": [464, 336],
      "id": "ef1e7110-83e8-4ab4-a916-1de2d76ebcd8",
      "name": "Anthropic Chat Model",
      "credentials": {
        "anthropicApi": {
          "id": "WHAwKkMwCUyPXaxT",
          "name": "Anthropic account"
        }
      }
    },
    {
      "parameters": {
        "resource": "message",
        "guildId": {
          "__rl": true,
          "value": "1429362234018238486",
          "mode": "list",
          "cachedResultName": "n8n",
          "cachedResultUrl": "https://discord.com/channels/1429362234018238486"
        },
        "channelId": {
          "__rl": true,
          "value": "1429429487275216957",
          "mode": "list",
          "cachedResultName": "jira",
          "cachedResultUrl": "https://discord.com/channels/1429362234018238486/1429429487275216957"
        },
        "content": "={{ $json.content }}",
        "options": {}
      },
      "type": "n8n-nodes-base.discord",
      "typeVersion": 2,
      "position": [1056, 96],
      "id": "b28f29fa-b319-4fc9-bd4c-64bf05feb6dd",
      "name": "Send a message1",
      "webhookId": "8d19bf2e-ff12-409d-a4ed-4651a0e69dda",
      "credentials": {
        "discordBotApi": {
          "id": "I7ISPUgIL3bwvNon",
          "name": "Discord Bot account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Chunk messages for Discord (2000 char limit)\nconst DISCORD_LIMIT = 1900; // Safe margin below 2000\n\nfunction chunkMessage(text, maxLength) {\n  if (text.length <= maxLength) {\n    return [text];\n  }\n  \n  const chunks = [];\n  let remaining = text;\n  \n  while (remaining.length > 0) {\n    if (remaining.length <= maxLength) {\n      chunks.push(remaining);\n      break;\n    }\n    \n    // Try to split at newline near the limit\n    let splitAt = maxLength;\n    const nearbyNewline = remaining.lastIndexOf('\\n', maxLength);\n    \n    if (nearbyNewline > maxLength * 0.7) {\n      splitAt = nearbyNewline + 1;\n    }\n    \n    chunks.push(remaining.substring(0, splitAt));\n    remaining = remaining.substring(splitAt);\n  }\n  \n  return chunks;\n}\n\nconst items = $input.all();\nconst result = [];\n\nfor (const item of items) {\n  const content = item.json.output || item.json.html || JSON.stringify(item.json);\n  const chunks = chunkMessage(content, DISCORD_LIMIT);\n  \n  chunks.forEach((chunk, index) => {\n    const partInfo = chunks.length > 1 ? `\\n\\nðŸ“„ Part ${index + 1}/${chunks.length}` : '';\n    result.push({\n      json: {\n        content: chunk + partInfo,\n        originalLength: content.length,\n        chunkIndex: index,\n        totalChunks: chunks.length\n      }\n    });\n  });\n}\n\nreturn result;"
      },
      "id": "dbb05f76-e5c1-4fe5-b9c0-4fdb3698c5a3",
      "name": "Chunk Daily Message",
      "type": "n8n-nodes-base.code",
      "position": [832, -160],
      "typeVersion": 2
    }
  ],
  "connections": {
    "Get ALL issues": {
      "main": [
        [
          {
            "node": "Get Comments for Each Issue",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Comments for Each Issue": {
      "main": [
        [
          {
            "node": "Merge Issues with Comments",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Issues with Comments": {
      "main": [
        [
          {
            "node": "Flatten Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Flatten Input": {
      "main": [
        [
          {
            "node": "Create Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Summary": {
      "main": [
        [
          {
            "node": "Chunk Daily Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Daily Evening Trigger": {
      "main": [
        [
          {
            "node": "Get ALL issues",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Anthropic Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Create Summary",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Chunk Daily Message": {
      "main": [
        [
          {
            "node": "Send a message1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "templateId": "9683",
    "templateCredsSetupCompleted": true,
    "instanceId": "ddc82d16cc7240c00217aba841deb918ec265f0424c035d728da8863c2e601b2"
  }
}
